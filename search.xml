<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>标准C++中的string类的用法总结</title>
      <link href="/2020/04/26/biao-zhun-c-zhong-de-string-lei-de-yong-fa-zong-jie/"/>
      <url>/2020/04/26/biao-zhun-c-zhong-de-string-lei-de-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>写这篇博客只是为了我方便查找</p><p>string类的构造函数：</p><p>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p><p>string类的字符操作：<br>const char &amp;operator[](int n)const;<br>const char &amp;at(int n)const;<br>char &amp;operator[](int n);<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char *data()const;//返回一个非null终止的c字符数组<br>const char *c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p><p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p><p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p><p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char *s);//用c类型字符串s赋值<br>string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p><p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char *s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p><p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小<br>int compare(const char *s) const;<br>int compare(int pos, int n,const char *s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p><p>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p><p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p><p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char *s, int pos = npos) const;<br>int rfind(const char *s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char *s, int pos = 0) const;<br>int find_first_of(const char *s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos = 0) const;<br>int find_first_not_of(const char *s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char *s, int pos = npos) const;<br>int find_last_of(const char *s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos = npos) const;<br>int find_last_not_of(const char *s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p><p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p><p>string类的插入函数：<br>string &amp;insert(int p0, const char *s);<br>string &amp;insert(int p0, const char *s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p><p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p><p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。<br>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p><p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，#include <sstream>头文件中<br>例如：<br>    string input(“hello,this is a test”);<br>    istringstream is(input);<br>    string s1,s2,s3,s4;<br>    is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>    ostringstream os;<br>    os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>    cout&lt;&lt;os.str();</p><hr><p>参考链接<br><a href="https://blog.csdn.net/u013046610/article/details/72674185" target="_blank" rel="noopener">https://blog.csdn.net/u013046610/article/details/72674185</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我搭建个人博客的流程及一些问题</title>
      <link href="/2019/12/07/guan-yu-wo-da-jian-ge-ren-bo-ke-de-liu-cheng-ji-yi-xie-wen-ti/"/>
      <url>/2019/12/07/guan-yu-wo-da-jian-ge-ren-bo-ke-de-liu-cheng-ji-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我是一个弱鸡新生，在这方面更是一个小白，但是我也想把博客玩起来。所以我找了很多资料，看了很多视频。终于在B站UP   CodeSheep的视频av44544186的帮助下完成了搭建。但是在搭建过程中也出现了很多问题，由于没有人交流，所以只能自己解决，所以各位在观看时发现错误或不足之处还请指出。</p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p>首先我们要准备node.js和git，这两款软件，当然我还下载了Vim。安装软件的过程就疯狂next就可以了。<br>安装好之后还需要将软件配置到path中去，可以自行百度一下。</p><hr><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><p>打开cmd输入npm install -g cnpm –registry=https:registry.npm.taobao.org,这是一个指向淘宝的镜像源，因为我们国内的镜像源下载速度很慢，利用这个可以节省时间。<br>然后输入cnpm install -g hexo-cli就会安装hexo框架。这时候需要建立一个空的文件夹，输入mkdir 你的文件夹名称，就可以建立了，这个文件夹的作用就是将你的hexo博客相关内容保存在其中，如果你在搭建过程中出错或者是效果达不到你的预期，你都可以直接将这个文件夹删除重新开始就可以了。<br>然后输入cd 你的文件夹名称进入这个文件夹。接下来输入hexo init来生成你的博客。再输入hexo s就可以启动你的博客了。<br>这时会出现<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>  这就是你的本地端口，然后按ctrl+c断开连接。这时你可以输入hexo n “文章标题”来写一篇文章，接着输入cd source/_posts/,你就可以编辑你的文章内容了。<br>在这里我用Vim编辑推向远端之后文章内容会出现一堆乱码。然后我改用了Vscode，如果你也出现这样的问题，也可以尝试一下我的解决办法，先从官网下载Vscode，然后将它的安装路径添加到path中去，最后在cmd中输入code.cmd 你的文章.md就可以编辑了，这样是没有乱码的。<br>这时返回到你最开始建立的文件夹下面，输入hexo clean清理一下，输入hexo g生成，再输入hexo s启动，你就可以在本地端口看到你所发表的博客了。至此hexo博客的搭建已经完成。</p><hr><h2 id="推向远端"><a href="#推向远端" class="headerlink" title="推向远端"></a>推向远端</h2><p>我是将我的hexo部署到github上的，这是免费的。<br>首先登入github的官网新建一个仓库，然后进行仓库命名，注意命名必须符合特定要求，你的github昵称.github.io,这样仓库就搭建完成了。<br>接下来回到cmd，这时需要安装一个git部署的插件，输入cnpm install –save hexo-deployer-git<br>装完之后需要设置一个东西，打开我的电脑，找到你最开始建立的那个文件夹，点进去会有一个_config.yml文件，用记事本打开它，在最底端找到type: ‘’,在单引号中输入git,然后另起一行输入 repo: 你的仓库链接，注意冒号后面有一个空格！<br>最后输入hexo d就可以将你的博客部署到远端了，然后我在这里还出现了git的账户问题，你可以利用git config–global对你的账户和密码做全局设置，也可以去git bash.exe里去配置你的身份。<br>但我不是这样解决的。我到这一步时它直接跳出了一个窗口让我输入账户和密码…然后解决了。<br>至此，整个博客搭建就完成了，你可以将你的博客域名分享给他人直接浏览了。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次搭建博客为我带来了许多相关经验。我也终于有了自己的博客，这是相当令人开心的。接下来我会去美化它，让它更加个性化。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h2 id="www-baidu-com"><a href="#www-baidu-com" class="headerlink" title="www.baidu.com"></a><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
